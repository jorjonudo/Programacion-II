### ‚úÖ **Ejercicio 93. Definiciones y aplicaciones**

**√Årbol:**  
Una estructura de datos jer√°rquica compuesta por nodos, donde cada nodo tiene un valor y una lista de nodos hijos. Se representa como una estructura en forma de √°rbol invertido, con un nodo ra√≠z.

**√Årbol binario:**  
Es un tipo especial de √°rbol en el que cada nodo tiene **como m√°ximo dos hijos**, llamados hijo izquierdo e hijo derecho.

**Aplicaciones comunes**:
- **√Årboles generales**: Representaci√≥n de jerarqu√≠as (por ejemplo, archivos y carpetas), expresiones matem√°ticas, estructuras XML/HTML.
- **√Årboles binarios**:
  - **B√∫squeda**: √Årboles binarios de b√∫squeda (BST).
  - **Compresi√≥n**: √Årboles de Huffman.
  - **IA**: √Årboles de decisi√≥n, juegos (minimax).
  - **Compiladores**: √Årboles de sintaxis.

---

### ‚úÖ **Ejercicio 94. Simulaci√≥n de inserci√≥n en √°rbol binario**

Inserciones en orden: `2, 1, 3, 8, 5, 2`  
(Seg√∫n implementaci√≥n dada: los duplicados van a la izquierda)

√Årbol resultante:

```
        2
       / \
      1   3
         / \
        2   8
           /
          5
```

---

### ‚úÖ **Ejercicio 95. Reglas para borrar un nodo en un √°rbol binario**

Hay tres casos:

1. **Nodo hoja** (sin hijos):  
   - Se elimina directamente.

2. **Nodo con un solo hijo**:  
   - Se reemplaza por su hijo.

3. **Nodo con dos hijos**:  
   - Se busca el **m√≠nimo del sub√°rbol derecho** (o m√°ximo del izquierdo) y se intercambian los valores. Luego se elimina el valor duplicado (que estar√° en un caso m√°s sencillo).

---

### ‚úÖ **Ejercicio 97. √Årbol rojo-negro**

Un **√°rbol rojo-negro** es un tipo de √°rbol binario de b√∫squeda **autobalanceado**.

#### Propiedades:
1. Cada nodo es rojo o negro.
2. La ra√≠z es negra.
3. Las hojas (nodos null) son negras.
4. Un nodo rojo no puede tener hijos rojos (no hay dos rojos seguidos).
5. Todos los caminos desde un nodo hasta sus hojas descendientes tienen el **mismo n√∫mero de nodos negros**.

---

### ‚úÖ **Ejercicio 98. Inserci√≥n en √°rbol rojo-negro (ejemplo simplificado)**

Sup√≥n que insertamos `10, 20, 30`:

1. Insertamos `10` ‚Üí ra√≠z negra.
2. Insertamos `20` (hijo derecho) ‚Üí rojo. No hay conflicto.
3. Insertamos `30` ‚Üí insertado como rojo, pero ahora `20` y `30` son rojos ‚áí **violaci√≥n**.

**Correcci√≥n**: rotaci√≥n izquierda en `10`, recoloreo.

Resultado:

```
      20(B)
     /    \
  10(R)   30(R)

```

---

### ‚úÖ **Ejercicio 99. Borrado de nodo rojo en √°rbol rojo-negro**

Borrar un nodo rojo es m√°s f√°cil que uno negro, ya que **no rompe la propiedad del n√∫mero de nodos negros**.  
Si el nodo a borrar es rojo y no tiene hijos ‚Üí se elimina directamente.  
Si tiene hijos, puede haber recoloreos o rotaciones dependiendo del caso, pero es m√°s complejo si es negro (para mantener el balance de negros).

---

### ‚úÖ **Ejercicio 100. ¬øQu√© es un `Set` y c√≥mo se implementa con √°rboles binarios?**

Un `Set` es una colecci√≥n que **no permite elementos duplicados**.

**Implementaci√≥n con BST:**
- Cada inserci√≥n se verifica con `lookup()`.
- Si ya existe el valor, no se inserta.
- De esta forma, se garantiza unicidad.

Ejemplo en Java:
```
TreeSet<Integer> set = new TreeSet<>();
set.add(10);
set.add(20);
set.add(10); // no se a√±ade

```

Internamente, `TreeSet` usa un **√°rbol rojo-negro**.

---

### ‚úÖ **Ejercicio 101. ¬øQu√© es un `Map` y c√≥mo se implementa con √°rboles binarios?**

Un `Map` es una estructura que almacena **pares clave-valor**.

**Implementaci√≥n con √°rboles binarios:**
- Las claves se ordenan seg√∫n comparaciones.
- Al buscar, insertar o eliminar, se comparan claves.
- Si la clave ya existe, se reemplaza el valor.

Ejemplo en Java:
```
TreeMap<String, Integer> mapa = new TreeMap<>();
mapa.put("a", 1);
mapa.put("b", 2);
mapa.put("a", 3); // reemplaza el valor de "a"

```
 
`TreeMap` tambi√©n se basa en un **√°rbol rojo-negro**.

Perfecto, vamos con los dos √∫ltimos ejercicios:

---

### ‚úÖ **Ejercicio 103. √Årbol con m√°s de dos hijos (√°rbol N-ario)**

Un **√°rbol N-ario** es una estructura de √°rbol donde **cada nodo puede tener un n√∫mero arbitrario de hijos**, no limitado a dos como en los √°rboles binarios.

#### üîß ¬øC√≥mo implementarlo?

Una forma com√∫n de implementarlo en Java:

```
class NTreeNode {
    int data;
    List<NTreeNode> children;

    NTreeNode(int data) {
        this.data = data;
        this.children = new ArrayList<>();
    }

    void addChild(NTreeNode child) {
        children.add(child);
    }
}

```

#### üìö Aplicaciones comunes:
- Representaci√≥n de archivos y carpetas.
- √Årboles de sintaxis abstracta en compiladores.
- Estructuras XML y HTML.
- Juegos con m√∫ltiples movimientos por turno.

---

### ‚úÖ **Ejercicio 104. Estructura de √°rbol con JDOM del fragmento HTML**

Fragmento:

```html
<TABLE>
  <TBODY>
    <TR>
      <TD>Shady Grove</TD>
      <TD>Aeolian</TD>
    </TR>
    <TR>
      <TD>Over the River, Charlie</TD>
      <TD>Dorian</TD>
    </TR>
  </TBODY>
</TABLE>
```

#### üå≥ Estructura como √°rbol en JDOM:

JDOM representa documentos XML/HTML como una estructura de √°rbol, donde cada elemento (`Element`) puede tener:

- Un nombre (`name`)
- Atributos
- Texto (contenido)
- Hijos (m√°s `Element`)

Estructura en forma de √°rbol:

```
Element: TABLE
‚îî‚îÄ‚îÄ Element: TBODY
    ‚îú‚îÄ‚îÄ Element: TR
    ‚îÇ   ‚îú‚îÄ‚îÄ Element: TD -> "Shady Grove"
    ‚îÇ   ‚îî‚îÄ‚îÄ Element: TD -> "Aeolian"
    ‚îî‚îÄ‚îÄ Element: TR
        ‚îú‚îÄ‚îÄ Element: TD -> "Over the River, Charlie"
        ‚îî‚îÄ‚îÄ Element: TD -> "Dorian"
```

Cada nivel anidado corresponde a un hijo del nodo anterior. Por ejemplo, `TR` es hijo de `TBODY`, que es hijo de `TABLE`.

Con JDOM se podr√≠a recorrer as√≠:

```java
Element table = document.getRootElement();
Element tbody = table.getChild("TBODY");

for (Element tr : tbody.getChildren("TR")) {
    for (Element td : tr.getChildren("TD")) {
        System.out.println(td.getText());
    }
}
```

---